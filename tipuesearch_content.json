{"pages":[{"title":"关于","tags":"pages","text":"关于我 大家好 ， 欢迎访问我的个人网站 。 此网站是使用开源的静态网站生成工具 Pelican 搭建于 GitHub Pages 上面的 。 有关 Pelican 及在 GitHub Pages 上面搭建个人静态网站的内容请访问相关官方网站获取 Pelican Pelican GitHub GitHub Pages 有关本网站及网站中的文章相关的问题请通过下面的方式联系我 ， 谢谢 ！ 联系 GitHub 主页 微信 ：lennyh Email： hhhhhf@foxmail.com","loc":"http://lennyhbt.github.io/pages/contactme.html"},{"title":"阅读列表","tags":"pages","text":"本页每日或每周更新从二 〇 一四年一月份开始的个人阅读清单 。 技术类 已读 20150122: LDAP 注入与防御剖析 Understanding LDAP - Design and Implementation 前三章 在读 20150122: 免费的编程中文书籍索引 未读单 非技术类 已读 在读 未读单 其他 已读 在读 未读单","loc":"http://lennyhbt.github.io/pages/reading-list.html"},{"title":"小结LDAP","tags":"技术杂谈","text":"LDAP 定义 本文不打算重复 LDAP 的标准定义 ， 仅谈一下自己的理解 。 LDAP 译为轻量级目录访问协议 ， 一般网上经常拿其与关系型数据库做类比并比较他们的不同 。 事实上 ，LDAP 既不是数据库也不是存储数据的方法 ， 而是用来访问数据的方法 。LDAP 可以访问的 是存储在目录信息树 （Directory Information Tree (DIT)） 中的数据 。 目录信息树存储数据的方法与关系型数据库非常的不同 。 关系型数据库的数据是存储在某一数据库 的某一数据表中的某以记录内的 ， 因此数据库中定位一条记录数据需要三个要素 ： 数据库 、 数据表 、 记录号 ； 目录信息树存储数据的方式是树状结构 ， 定位一条数据的方法是从树根到叶子节点 的唯一路径 ， 数据就存储在叶子节点中 。 由此可见 ，LDAP 与关系型数据库类比其实是两种数据存储与访问方式的类比 。 LDAP 是访问目录信息树中数据的协议 事实上 ，LDAP 仅定义了访问协议 ， 数据的真实存储方式并不在 LDAP 的考量范围内 ， 即只要提供了 目录访问接口的数据都可以通过 LDAP 协议来访问 ， 如果关系型数据库实现了该接口也是可以通过 LDAP 协议来反问的 。 从这个角度来讲 ， 确实不应该将 LDAP 与关系型数据库做类比 。 LDAP 特性 且 LDAP 对数据的读取和查询做了优化 ， 并不适用于经常变动的数据 。 LDAP 不定义客户端和服务端的工作方式 ， 但会定义客户端和服务端的通信方式 ， 另外 ，LDAP 还会定义 LDAP 数据库的访问权限及服务端数据的格式和属性 。 LDAP 有三种基本的通信机制 ： 没有处理的匿名访问 ； 基本的用户名 、 密码形式的认证 ； 使用 SASL、SSL 的安全认证方式 。LDAP 和很多其他协议一样 ， 基于 tcp/ip 协议通信 ， 注重服务的可用性 、 信息的保密性等等 。 部署了 LDAP 的应用不会直接访问目录中的内容 ， 一般通过函数调用或者 API， 应用可以通过定义的 C、Java 的 API 进行访问 ，Java 应用的访问方式为 JNDI(Java Naming and Directory Interface)。 LDAP 结构 目录信息树 目录信息树以目录条目 （entry） 来存储和组织数据 ， 每一个目录条目通常描述一个对象 （ 例如 ： 一个人 ）， 目录条目有一个唯一名 （DN，distinguished name） 进行标识 。DN 由一系列的相对唯一名 （RDN，relative distinguished name） 来标识 。 每一个目录条目由一或多个属性来描述该条目 ， 例如描述人的条目有一个 电话号码的属性 。 引用一张 Understanding LDAP Design and Implementation 的图示 ， 目录条目根据他们在目录信息树中的位置命名 ， 上图底部的目录条目的 DN 唯一名是 : cn=John Smith,ou=people,o=ibm,c=us. The organizational group people has the DN of ou=people,o=ibm,c=us. LDAP 的查询等操作语句在这里就不介绍了 ， 有需求的可以在参考资料中找 。 LDAP 安全 LDAP 安全相关的资料请参考 LDAP 注入与防御剖析 LDAP 服务器配置 请参考 OpenLDAP 管理员指南 参考资料 LDAP 注入与防御剖析","loc":"http://lennyhbt.github.io/ldap_overview.html"},{"title":"系统安全的思考","tags":"技术杂谈","text":"世上并没有绝对的安全 ， 只有安全成本的问题 。 真正的安全不过是一种意识 。 过往 网络安全 工作相关 ， 做的一直是跟系统安全相关的东西 。 前几年的时候在做的是网络安全 ， 所谓的网络安全 。 说是网络安全 ， 其实跟安全的关系不是很大 ， 主要还是做网络设备 ， 支持各种协议及功能 ， 还要尽可能地提高性能 。 跟安全的那点儿关系就是 ， 在网络设备里面嵌入了部分跟安全相关的功能 。 想来 ， 像访问包过滤 （ 很多厂商也叫 ACL， 访问控制列表 ），NAT 转换这些跟安全的关联性也不大 吧 ， 他们是更倾向于控制和管理的功能 ；DPI 协议识别呢 ？ 算是个基础功能吧 ， 接下来可以根据 识别结果做控制与分析 ， 也可以继续深入的做攻击防御 。 那么真正跟安全密切相关的功能有哪些呢 ？ MAC/IP 绑定 ， 攻击防护 ， 网页防篡改等 ， 这在网络安全设备像硬件防火墙这些 ， 的功能中 ， 着实的算不算主要的功能吧 ， 也不常用 。 只是说多一个功能就多一个卖点 。 其实网路安全设备很少关注自身的安全 ， 挺多厂商把侧重点放在了性能上面 。 真的有可以提供整体安全方案的厂商吗 ？ 我是不信的 ， 至少国内的厂商是这样的吧 。 并不是说这些设备没有必要 ， 确实很多功能还是很好的 ， 但是跟系统安全相差的还是很远的吧 。 现今 真正的系统安全 换过工作之后负责系统的一个安全模块 ， 对安全有了稍微深入一点的理解 。 安全与易用 ， 在某种程度上会有一些冲突 ， 但这个程度肯定不会很大 。 易用也是一种安全 ， 想用户所想 。 系统遭遇到安全威胁时 ， 用户能想到的 ， 系统帮他去做了 ， 用户没有想到的 ， 系统也帮他做好了 ， 系统也帮他做了 ， 这是易用 ， 也是安全 。 因此 ， 系统的正确行为定义也是安全的基础 ， 在威胁出现时不能做出正确响应 ， 就没有安全可言了 。 安全是不能有短板的 ， 不仅要保证数据的安全 ， 还要保证用户输入的安全 ， 传输的安全等等 ， 缺了任何一个环节 ， 就像系统有了漏洞一样 ， 攻击者顺着这个漏洞可以获取系统中的很多东西 。 安全的核心工作应该是在后台默默完成的 ， 很少的提示用户 ， 更很少让用户来选择 ， 就像武侠小说中的扫地僧 ， 绝大多数时候用户都意识不到他的存在 ， 他只是在后台默默的做着 自己的工作 ， 他的存在只是为了那突然的攻击出现的时候 。 稳定也是一种安全 ， 我们无法保证每一次的修改都可以做到全系统的测试 ， 而每次修改对系统 哪些模块有影响又是不完全预知的 ， 尤其是系统的基础架构 ， 略一更改影响面都很大 。 系统不 稳定就很容易出问题 。 其实 ， 安全是一种意识 ， 这种意识应该无处不在 。 开发中的安全意识保证我们的系统漏洞更少 ， 系统更稳健 。 如果我们在开发中测试代码随便写 ， 变量不初始化 ， 溢出不检查 ， 系统就很容易被攻击 。 使用中的安全意识保证了我们自己这个系统更加不容易被骗 。 我们自己如果更加的注意自己的隐私不随意泄露 ， 遇到电话 / 网络诈骗时可以多核实 ， 社会 工程学也不那么容易就获取到我们的电话 、 邮箱 、 密码等信息了 。 只要在系统的所有环节做到一般性的防护 ， 就已经比在系统的关键环节做很强的防护但在 其他环节不防护安全很多了 。 将来 系统的安全机制 系统还是要提供必要的基础的安全机制供其他的系统组件使用的 。 如果需要系统提供的一些基础功能需要每个系统组件自己实现并维护 ， 轮子重复造不说 ， 安全隐患的增加也是很严重的 ， 因为保证这些基础功能的安全变的更加的麻烦 。 修复起来也很麻烦 。 系统的安全机制做的好 ， 省了很多的麻烦 。 我们需要更加深入的研究与实现系统的安全机制 。","loc":"http://lennyhbt.github.io/system_security_thought.html"},{"title":"VPN 高级选项那些事","tags":"技术问题","text":"一 、VPN 高级选项 VPN 高级选项有哪些 ， 都是什么意思 DNS 搜索域 These are for the mechanism for going from a machine name to a Fully Qualified Domain Name. DNS searches can only look at a Fully Qualified Domain Name, such as mymachine.example.com. But, it's a pain to type out mymachine.example.com, you want to be able to just type mymachine. Using Search Domains is the mechanism to do this. If you type a name that does not end with a period, it knows it needs to add the search domains for the lookup. So, lets say your Search Domains list was: example.org, example.com mymachine would try first mymachine.example.org, not find it, then try mymachine.example.com, found it, now done. mymachine.example.com would try mymachine.example.com.example.org (remember, it doesn't end with a period, still adds domains), fail, then mymachine.example.com.example.com, not find it, fall back to mymachine.example.com, found it, now done mymachine.example.com. Ends with a period, no searching, just do mymachine.example.com Soooo..... If you have your own DNS domain such as example.com, put it there. If not, ignore it. It really is more corporate than a home setting. 参考 What is the \"Search Domains\" field for in the tcp/ip DNS settings control panel/preference pane for?> DNS 服务器 域名系统 （ 英文 ：Domain Name System， 縮寫 ：DNS） 是因特网的一项服务 。 它作为将域名和 IP 地址相互映射的一个分布式数据库 ， 能够使人更方便的访问互联网 。DNS 使用 TCP 和 UDP 端口 53。 当前 ， 对于每一级域名长度的限制是 63 个字符 ， 域名总长度则不能超过 253 个字符 。 参考 域名系统 转发路线 即转发路由 ， 因 DNS 服务器不提供任何服务 ， 因此所有的请求都需要经过转发才能到达可以响应请求的服务器 ， 转发路线即配置发往哪些地址请求的需经过 VPN 转发 。 为什么需要这些选项 这些选项其实只是一些基础的网络参数 ， 因此所有的网络连接 （ 包括 VPN） 都需要这些选项 。 但是并不是所有的网络连接都需要手动配置这些参数 。 那么为什么 VPN 更加的需要配置这些参数呢 ？ VPN 是一种常用于连接中 、 大型企业或团体与团体间的私人网络的通讯方法 。 虚拟私人网络的讯息透过公用的网络架构 （ 例如 ： 互联网 ） 来传送内联网的网络讯息 。 这种技术可以用不安全的网络 （ 例如 ： 互联网 ） 來傳送可靠 、 安全的訊息 。[ 摘自 危机百科 ] DNS 请求呢 ？ 在未配置 VPN 之前 ， 我们使用的是不安全网络上的 DNS 服务器 ， 如果连接到 VPN 之后我们仍然连接不安全网络上的 DNS 服务器 ， 如何保证我们的数据安全 ？ DNS 搜索域是一个方便使用的选项 。 路由则指定了哪些数据是需要 VPN 网络来保护的 ， 如果不指定 ， 或者系统中所有的流量都经过 VPN， 但是 VPN 连接到的私有网络并不能提供不安全网络中所有的网络请求 ； 或者 系统中所有的流量都不经过 VPN 服务器 ， 连接 VPN 干嘛 ， 当摆设吗 ？ 由此可见 ， 这些网络高级选项在 VPN 的配置中还是很有必要的 。 二 、 关于 connman 使用 connman 管理系统网络连接的例子并不多 ， 网络上相关的资料也很少 。 万幸的是 ，connman 自带的文档 (doc 目录 ) 大概可以把 connman 的设计原则和使用方法解释清除了 。 以下内容及为参考该文档及源代码以及本人的推测得来的 ， 不一定准确 。 connman 是如何管理所有连接的 src/provider.c -- 管理 connman 中每一个 （ 不是每一种 ） 连接 ， 保存连接 。 src/service.c -- 管理连接服务 。 src/task.c -- connman 中对连接的代码 ， 负责创建与维护真正的连接进程 。 这几个代码文件大概实现了 connman 连接管理的框架 ， 但是新建连接后还需要设置很多的网络参数 ， 等等 ， 正是这一部分使得 connman 显得更加的复杂 。 connman 是如何管理网络参数的 （ 路由 、DNS 等 ） connman 中对网络参数的管理是基于连接的 ， 即每个连接都有不同的网络参数配置 ， 该连接生效时 connman 会根据 连接属性更新系统的网络参数 。 connman 封装了很多对系统网络参数修改的 API， 如下列举部分 : src/inet.c -- 实现对系统路由的配置 src/ipconfig.c -- 实现对系统地址的配置 src/resolver.c -- 实现对系统 DNS 的配置 ，connman 有选项支持 dns 代理 Note connman-vpn 与上述描述并不完全一致 。 当然 ，vpn 连接也是由 connman_task 创建具体的任务来连接的 ， 但是 。 vpn/vpn-manager.c 提供新建 / 删除 VPN 连接的功能 (create/remove/get_connections...)。 vpn/vpn-provider.c 提供了 vpn 连接 / 断开功能 (do_connect/do_disconnect...)。 vpn 连接建立 / 删除时会发送 ConnectionAdded/ConnectionRemoved 信号 ， vpn 连接时会发送 PropertyChanged 信号 。 connman 的 vpn 插件会监听这些信号 ， 在新建 / 删除 vpn 连接时会在 connman 进程中建立该连接的 provider 及 service。 connman 监听到 PropertyChanged 信号时会根据属性设置系统当前的网络参数 （dns 等 ）。 推荐文档阅读顺序 ： vpn-overview.txt -> vpn-manager-api.txt -> vpn-connection-api.txt 四 、Qt 、QML and D-Bus Connman 是以 daemon 进程在系统后台运行的 ， 要访问 Connman 提供的服务 ， 只能通过进程间通信类似的机制 。 事实上 Connman 提供的服务都是以 D-Bus 方法即信号作为 API 接口的 。 例如 ， 新建 / 删除 VPN、 连接 VPN 的接口如下 ： 1 2 3 static DBusMessage * create ( DBusConnection * conn , DBusMessage * msg , void * data ); static DBusMessage * remove ( DBusConnection * conn , DBusMessage * msg , void * data ); static DBusMessage * do_connect ( DBusConnection * conn , DBusMessage * msg , void * data ); Qt 对 D-Bus 的支持 Qt 对 D-Bus 的支持算是基本完善 ， 该有的都可以有 ， 不该有的可能会可以有 。（：D） 可以通过 Qt 中 D-Bus 相关的库函数创建 D-Bus 服务 ， 或者使用别人提供的服务 。 对发送接收数据类型的支持也比较完整 ， 不仅能够 收发基本的整数 、 字符串等 ， 复杂的字典 、 数组等自然也不在话下 。 但是 Qt 对 DBUS_TYPE_STRUCT 的支持需要稍多做一些工作 ， 下面的章节会有介绍 。 QML 对 D-Bus 的支持 很遗憾 ，QML 原生并不支持 D-Bus， 但是可以通过两种变通的途径使用 。 第一是 ， 在 C++ 代码中封装调用 D-Bus 的接口 ， 并注册到 QML 中 。 第二种 ， 是采用非 QT 官方的插件 ， 实现 ， 例如 ： Nemo Mobile D-Bus QML Plugin 好吧 ， 其实是一种 ， 第二种其实同样是 C++ 代码中封装了调用 D-Bus 的接口 ， 但是除此之外 ， 还有什么办法可以扩展 QML 不支持的功能吗 ？ Qt 对 D-Bus 中 DBUS_TYPE_STRUCT 的支持 Qt 有自己的类型系统 ， 不知是该庆幸还是该懊恼 。 Qt 的类型系统极大的丰富了我们的精神文化生活 ， 噢不 ， 是极大的方便了我们的开发 ，QVariant， 信号 / 槽 （QObject） 等等 。 但是这样一来我们自己定义的类型却无法使用这些方便的特性 ， 而且 Qt D-Bus 也不支持自定义类型的发送与接收 。 幸运的是 ， 上帝在关上这扇门的时候悄悄给我们开了一扇窗 ， 我们可以将自己定义的类型注册到 Qt 的元类型系统中去 ， 这样我们自己定义的类型也可以使用 Qt 提供的很多方便的特性了 ， 最重要的是我们自定义的结构也可以通过 Qt 的 D-Bus 接口发送与接收了 。 创建方法在此不表 ， 无非是在适当的地方增加几次调用 : Q_DECLARE_METATYPE(Type)； int qRegisterMetaType(const char * typeName)； int qDBusRegisterMetaType()； 详情参看如下链接 ： 创建自定义 Qt 类型 Problems with marshalling a struct to Qt/DBus 五 、Linux 连接管理 都有哪些连接管理实现 Android： ConnectivityManager NetworkManager NetworkManager is a set of co-operative tools that make networking simple and straightforward. Whether Wi-Fi, wired, bond, bridge, 3G, or Bluetooth, NetworkManager allows you to quickly move from one network to another: once a network has been configured and joined, it can be detected and re-joined automatically the next time its available. ConnMan ConnMan is a daemon for managing Internet connections within embedded device and integrates a vast range of communication features usually split between many daemons such as DHCP, DNS and NTP. The result of this consolidation is low memory consumption with a fast, coherent, synchronized reaction to changing network conditions. 为什么需要连接管理 几乎所有的现代操作系统都有统一的连接管理 ， 这是为什么呢 ？ 其实这个问题我也不知道 。 所以 ， 下面的内容纯属揣测 ， 如有不对恳请指正 。 大概是有两个原因吧 ， 我想 。 一是便于用户的配置 ， 试想 ， 用户连接上一个新的网络 （ 有线 、 无线 、VPN 等 ） 后 ， 要手动的去修改 DNS、 路由 、 地址等信息 ， 肯定是不可原谅的 ， 或者进一步 ， 需要在不同的位置分别通过不用的程序去配置不同的网络参数 ， 少改了一项网络可就不正常了哦 。 二是便于网络的管理 ， 如果每种连接自己管自己的网络配置 ， 可是这些配置的生效可是在一个系统上的 ， 于是每个程序都去修改 DNS 配置 ， 路由 ， 地址等信息 ， 你确保不会改乱 ？ 其实反观其他子系统 ， 声音肯定要在所有要播放 / 录制声音的程序后面有一个 daemon 来负责系统的混音及播放工作 ， 不可能每个程序各播各的 ， 你肯定不原因听到那种声音的 。 显示子系统不可能是每个想要在屏幕上显示东西的程序自己向屏幕上写吧 ， 这样我显示了一个窗口 ， 你显示了一个通知 ， 我有显示了一个文档 ， 你确定用户能够看得请 ？ 所以还是需要有显示管理器在后面跑的 。 同理 ， 系统的网络配置大家一起改 ， 你确定不会改乱 ？ 这大概是一个趋势吧 ， 只有一种或者两种网络连接的时候 ， 我可以随便改 ， 要是系统有很多种连接类型 ， 可就不能胡来了 。","loc":"http://lennyhbt.github.io/vpn_advance_options_misc.html"},{"title":"JavaScript的移位运算与IP地址处理","tags":"技术问题","text":"JS 左移运算符号位的问题 最近在做项目时有一个需求 ， 将用户输入的 地址 / 掩码 对解析出来 ， 并将数字掩码转换成点分的格式 。 想到在 C 代码里面应该还算容易实现 ， 通过最大 32 位整数位移就可完成 ， 但是在 JavaScript 中如何实现还是很不清楚的 。 因为考虑到 JavaScript 是弱类型的语言 ， 首先就会遇到数字和字符串的转换等问题 ， 接着还有按位操作的问题也不知道在 JavaScript 中如何实现 。 然后开始查询资料尝试解决这些问题 。 数字和字符串类型的转换是不需要的 ， 写代码尝试了下应该 JavaScript 自动做了类型转换 。 首先想到的思路是根据最大 32 位整数位移获取掩码对应的整数值 ， 然后将结果转换成点分格式的字符串 。 在网上找到了如下的代码 。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function ip2long ( ip ) { var ipl = 0 ; ip . split ( '.' ). forEach ( function ( octet ) { ipl <<= 8 ; ipl += parseInt ( octet ); }); return ( ipl >>> 0 ); } function long2ip ( ipl ) { return ( ( ipl >>> 24 ) + '.' + ( ipl >> 16 & 255 ) + '.' + ( ipl >> 8 & 255 ) + '.' + ( ipl & 255 ) ); } 有了这两个方法就可以将计算得到的掩码整数值转换成点分格式了 。 但是在做位运算的时候发现了一个坑 ， 在一边查资料一边尝试实现的第一个版本中 ， 掩码为 0 和掩码为 32 产生的结果一样 ， 都是 255.255.255.255。 看来此方案不可行 ， 接着查资料发现了一个新的思路 ， 根据掩码生成四个小于等于 255 的值 ， 将这四个值拼成点分格式 。 这样实现避免了对符号位的操作 ， 甚好 。 1 2 3 4 5 6 7 8 9 function createNetmaskAddr ( bitCount ) { var mask = []; for ( i = 0 ; i < 4 ; i ++ ) { var n = Math . min ( bitCount , 8 ); mask . push ( 256 - Math . pow ( 2 , 8 - n )); bitCount -= n ; } return mask . join ( '.' ); } 参考资料 Unsigned Integer in Javascript ECMAScript 位运算符 CIDR to netmask converion in javascript","loc":"http://lennyhbt.github.io/javascript-bit-operation.html"},{"title":"Hello Pelican & GitHub Pages","tags":"佛说","text":"不知不觉做技术也已经四年有余了 ， 四年来不管在技术 、 工作及生活中都积累了一些不错的经验教训 （ 以及很多好玩的东西 ）。 但是碍于个人的懒惰 ， 虽偶有尝试 ， 却从未能够坚持一直把学到的东西记录下来供以后 。 于是 ， 很多好东西消逝在时光中 ， 余实在不忍继续这样下去 。 于是 ， 下定决心 ， 在此搭建此平台 ， 希望自己能够坚持不懈 ， 把那些值得记录的东西记录下来 。 愿有机会满怀高兴的回翻这些有趣的东西 ， 愿有趣的东西越来越多 。","loc":"http://lennyhbt.github.io/helloworld.html"}]}